#version 330 core

// In
in vec4 modelPosition;
in vec4 vertexNormal;

// Uniform
uniform sampler2D textureFrontSampler;
uniform sampler2D textureSideSampler;
uniform float chinVerticalPos;
uniform float eyeVerticalPos;
uniform float LEyeVerticalTexPos;
uniform float REyeVerticalTexPos;

// constants
#define M_PI 3.1415926535897932384626433832795


// how much of the front texture should be used?
float frontFactor(float phi)
{
	float val=-cos(phi);
	val=clamp(val, 0.0, 1.0);

	return val;
}


// how much of the side texture should be used?
float sideFactor(float phi)
{
	float val=sin(phi);
	val=clamp(val, 0.0, 1.0);
	
	return val;
}


// cylinder mapping of the two textures onto face model
vec4 textureShading()
{
	// phi coordinate of cylinder
	// phi=0 at the back of the face and then increases in CCW direction to 2pi
	float phi=atan(modelPosition.z, -modelPosition.x)+M_PI;	

	
	// vertical coordinate of cylinder 
	//float vertical=1.0-(modelPosition.y+2.25)/4.0; // TODO read value from image processing app!
	float vertical=(modelPosition.y-chinVerticalPos)/(eyeVerticalPos-chinVerticalPos);
	vertical = (vertical + LEyeVerticalTexPos) / (1 + 2 * LEyeVerticalTexPos);
	vertical = 1.0 - vertical;
	
	// get color from texture
	vec2 texCoordsFront=vec2( (phi-(M_PI/2.0)) / M_PI, vertical);
	vec3 texColorFront = vec3(texture(textureFrontSampler, texCoordsFront));
	
	vec2 texCoordsSide1=vec2( phi / M_PI, vertical);
	vec3 texColorSide1 = vec3(texture(textureSideSampler, texCoordsSide1));
		
	vec2 texCoordsSide2=vec2( 1.0-((phi-M_PI) / M_PI), vertical);
	vec3 texColorSide2 = vec3(texture(textureSideSampler, texCoordsSide2));
	
	
	
	// smooth overlapping of textures. 
	float ff=frontFactor(phi),sf1=sideFactor(phi),sf2=sideFactor(phi+M_PI);
	ff*=ff;
	sf1*=sf1;
	sf2*=sf2;	
	
	// final color
	return vec4(ff*texColorFront+sf1*texColorSide1+sf2*texColorSide2,1.0);	

	// test color
	//return vec4(vertical,vertical,vertical,1.0);
}


// main
void main()
{  	
	gl_FragColor= textureShading();
}




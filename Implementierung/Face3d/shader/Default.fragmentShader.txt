#version 330 core

// In
in vec4 modelPosition;
in vec4 vertexNormal;

// Uniform
uniform sampler2D textureFrontSampler;
uniform sampler2D textureSideSampler;

// constants
#define M_PI 3.1415926535897932384626433832795


// how much of the front texture should be used?
float frontFactor(float phi)
{
	float val=-cos(phi);
	val=clamp(val, 0.0, 1.0);
	
	return val;
}


// how much of the side texture should be used?
float sideFactor(float phi)
{
	float val=sin(phi);
	val=clamp(val, 0.0, 1.0);
	
	return val;
}


// cylinder mapping of the two textures onto face model
vec4 textureShading()
{
	// phi coordinate of cylinder
	// phi=0 at the back of the face and then increases in CCW direction to 2pi
	float phi=atan(modelPosition.z, -modelPosition.x)+M_PI;	

	
	// z coordinate of cylinder 
	float z=1.0-(modelPosition.y+2.0)/4.0; // TODO read value from image processing app!

	
	// get color from texture
	vec2 texCoordsFront=vec2( (phi-(M_PI/2.0)) / M_PI, z);
	vec3 texColorFront = vec3(texture(textureFrontSampler, texCoordsFront))*frontFactor(phi);
	
	vec2 texCoordsSide1=vec2( phi / M_PI, z);
	vec3 texColorSide1 = vec3(texture(textureSideSampler, texCoordsSide1))*sideFactor(phi);
		
	vec2 texCoordsSide2=vec2( 1.0-((phi-M_PI) / M_PI), z);
	vec3 texColorSide2 = vec3(texture(textureSideSampler, texCoordsSide2))*sideFactor(phi+M_PI);
	
	// rescale for smooth overlapping regions of front and side texture
	float totalFactor=frontFactor(phi)+sideFactor(phi)+sideFactor(phi+M_PI);
	
	// final color
	return vec4(texColorFront+texColorSide1+texColorSide2,1.0)/totalFactor;		
}


// main
void main()
{  	
	gl_FragColor=textureShading();
}



